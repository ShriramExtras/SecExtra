// /* Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    Copyright The GNU Toolchain Authors.
//    This file is part of the GNU C Library.

//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.

//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.

//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.  */

// /*
//  *	ISO C99 Standard: 7.20 General utilities	<stdlib.h>
//  */

// /* Copy N bytes of SRC to DEST.  */
// extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
// 		     size_t __n) __THROW __nonnull ((1, 2));
// /* Copy N bytes of SRC to DEST, guaranteeing
//    correct behavior for overlapping strings.  */
// extern void *memmove (void *__dest, const void *__src, size_t __n)
//      __THROW __nonnull ((1, 2));

// /* Copy no more than N bytes of SRC to DEST, stopping when C is found.
//    Return the position in DEST one byte past where C was copied,
//    or NULL if C was not found in the first N bytes of SRC.  */
// #if defined __USE_MISC || defined __USE_XOPEN || __GLIBC_USE (ISOC2X)
// extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
// 		      int __c, size_t __n)
//     __THROW __nonnull ((1, 2)) __attr_access ((__write_only__, 1, 4));
// #endif /* Misc || X/Open.  */

// /* Set N bytes of S to C.  */
// extern void *memset (void *__s, int __c, size_t __n) __THROW __nonnull ((1));

// /* Compare N bytes of S1 and S2.  */
// extern int memcmp (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
//    Return some non-zero value otherwise.

//    Essentially __memcmpeq has the exact same semantics as memcmp
//    except the return value is less constrained.  memcmp is always a
//    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
//    or bcmp are correct implementations.

//    __memcmpeq is meant to be used by compilers when memcmp return is
//    only used for its bolean value.

//    __memcmpeq is declared only for use by compilers.  Programs should
//    continue to use memcmp.  */
// extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Search N bytes of S for C.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
// extern "C++"
// {
// extern void *memchr (void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
// extern const void *memchr (const void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

// # ifdef __OPTIMIZE__
// __extern_always_inline void *
// memchr (void *__s, int __c, size_t __n) __THROW
// {
//   return __builtin_memchr (__s, __c, __n);
// }

#include <string.h>
// /* Compare N bytes of S1 and S2.  */
// extern int memcmp (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
//    Return some non-zero value otherwise.

//    Essentially __memcmpeq has the exact same semantics as memcmp
//    except the return value is less constrained.  memcmp is always a
//    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
//    or bcmp are correct implementations.

//    __memcmpeq is meant to be used by compilers when memcmp return is
//    only used for its bolean value.

//    __memcmpeq is declared only for use by compilers.  Programs should
//    continue to use memcmp.  */
// extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Search N bytes of S for C.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
// extern "C++"
// {
// extern void *memchr (void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
// extern const void *memchr (const void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

// # ifdef __OPTIMIZE__
// __extern_always_inline void *
// memchr (void *__s, int __c, size_t __n) __THROW
// {
//   return __builtin_memchr (__s, __c, __n);
// }
char *strrev(char *string)
{
    if (string && *string)
    { // /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }
        char *b = string, *e = string + strlen(string) - 1;
        while (b < e)
        { // /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }
            char t = *b;
            // /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }
            *b++ = *e;
            *e-- = t; // /* Compare N bytes of S1 and S2.  */
                      // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                      //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }
        }
    } // /* Compare N bytes of S1 and S2.  */
      // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
      //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }
    return string;
}
// /* Compare N bytes of S1 and S2.  */
// extern int memcmp (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
//    Return some non-zero value otherwise.

//    Essentially __memcmpeq has the exact same semantics as memcmp
//    except the return value is less constrained.  memcmp is always a
//    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
//    or bcmp are correct implementations.

//    __memcmpeq is meant to be used by compilers when memcmp return is
//    only used for its bolean value.

//    __memcmpeq is declared only for use by compilers.  Programs should
//    continue to use memcmp.  */
// extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Search N bytes of S for C.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
// extern "C++"
// {
// extern void *memchr (void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
// extern const void *memchr (const void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

// # ifdef __OPTIMIZE__
// __extern_always_inline void *
// memchr (void *__s, int __c, size_t __n) __THROW
// {
//   return __builtin_memchr (__s, __c, __n);
// }// /* Compare N bytes of S1 and S2.  */
// extern int memcmp (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
//    Return some non-zero value otherwise.

//    Essentially __memcmpeq has the exact same semantics as memcmp
//    except the return value is less constrained.  memcmp is always a
//    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
//    or bcmp are correct implementations.

//    __memcmpeq is meant to be used by compilers when memcmp return is
//    only used for its bolean value.

//    __memcmpeq is declared only for use by compilers.  Programs should
//    continue to use memcmp.  */
// extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Search N bytes of S for C.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
// extern "C++"
// {
// extern void *memchr (void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
// extern const void *memchr (const void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

// # ifdef __OPTIMIZE__
// __extern_always_inline void *
// memchr (void *__s, int __c, size_t __n) __THROW
// {
//   return __builtin_memchr (__s, __c, __n);
// }// /* Compare N bytes of S1 and S2.  */
// extern int memcmp (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
//    Return some non-zero value otherwise.

//    Essentially __memcmpeq has the exact same semantics as memcmp
//    except the return value is less constrained.  memcmp is always a
//    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
//    or bcmp are correct implementations.

//    __memcmpeq is meant to be used by compilers when memcmp return is
//    only used for its bolean value.

//    __memcmpeq is declared only for use by compilers.  Programs should
//    continue to use memcmp.  */
// extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Search N bytes of S for C.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
// extern "C++"
// {
// extern void *memchr (void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
// extern const void *memchr (const void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

// # ifdef __OPTIMIZE__
// __extern_always_inline void *
// memchr (void *__s, int __c, size_t __n) __THROW
// {
//   return __builtin_memchr (__s, __c, __n);
// }// /* Compare N bytes of S1 and S2.  */
// extern int memcmp (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
//    Return some non-zero value otherwise.

//    Essentially __memcmpeq has the exact same semantics as memcmp
//    except the return value is less constrained.  memcmp is always a
//    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
//    or bcmp are correct implementations.

//    __memcmpeq is meant to be used by compilers when memcmp return is
//    only used for its bolean value.

//    __memcmpeq is declared only for use by compilers.  Programs should
//    continue to use memcmp.  */
// extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Search N bytes of S for C.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
// extern "C++"
// {
// extern void *memchr (void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
// extern const void *memchr (const void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

// # ifdef __OPTIMIZE__
// __extern_always_inline void *
// memchr (void *__s, int __c, size_t __n) __THROW
// {
//   return __builtin_memchr (__s, __c, __n);
// }// /* Compare N bytes of S1 and S2.  */
// extern int memcmp (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
//    Return some non-zero value otherwise.

//    Essentially __memcmpeq has the exact same semantics as memcmp
//    except the return value is less constrained.  memcmp is always a
//    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
//    or bcmp are correct implementations.

//    __memcmpeq is meant to be used by compilers when memcmp return is
//    only used for its bolean value.

//    __memcmpeq is declared only for use by compilers.  Programs should
//    continue to use memcmp.  */
// extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Search N bytes of S for C.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
// extern "C++"
// {
// extern void *memchr (void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
// extern const void *memchr (const void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

// # ifdef __OPTIMIZE__
// __extern_always_inline void *
// memchr (void *__s, int __c, size_t __n) __THROW
// {
//   return __builtin_memchr (__s, __c, __n);
// }// /* Compare N bytes of S1 and S2.  */
// extern int memcmp (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
//    Return some non-zero value otherwise.

//    Essentially __memcmpeq has the exact same semantics as memcmp
//    except the return value is less constrained.  memcmp is always a
//    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
//    or bcmp are correct implementations.

//    __memcmpeq is meant to be used by compilers when memcmp return is
//    only used for its bolean value.

//    __memcmpeq is declared only for use by compilers.  Programs should
//    continue to use memcmp.  */
// extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Search N bytes of S for C.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
// extern "C++"
// {
// extern void *memchr (void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
// extern const void *memchr (const void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

// # ifdef __OPTIMIZE__
// __extern_always_inline void *
// memchr (void *__s, int __c, size_t __n) __THROW
// {
//   return __builtin_memchr (__s, __c, __n);
// }// /* Compare N bytes of S1 and S2.  */
// extern int memcmp (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
//    Return some non-zero value otherwise.

//    Essentially __memcmpeq has the exact same semantics as memcmp
//    except the return value is less constrained.  memcmp is always a
//    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
//    or bcmp are correct implementations.

//    __memcmpeq is meant to be used by compilers when memcmp return is
//    only used for its bolean value.

//    __memcmpeq is declared only for use by compilers.  Programs should
//    continue to use memcmp.  */
// extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Search N bytes of S for C.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
// extern "C++"
// {
// extern void *memchr (void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
// extern const void *memchr (const void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

// # ifdef __OPTIMIZE__
// __extern_always_inline void *
// memchr (void *__s, int __c, size_t __n) __THROW
// {
//   return __builtin_memchr (__s, __c, __n);
// }// /* Compare N bytes of S1 and S2.  */
// extern int memcmp (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
//    Return some non-zero value otherwise.

//    Essentially __memcmpeq has the exact same semantics as memcmp
//    except the return value is less constrained.  memcmp is always a
//    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
//    or bcmp are correct implementations.

//    __memcmpeq is meant to be used by compilers when memcmp return is
//    only used for its bolean value.

//    __memcmpeq is declared only for use by compilers.  Programs should
//    continue to use memcmp.  */
// extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Search N bytes of S for C.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
// extern "C++"
// {
// extern void *memchr (void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
// extern const void *memchr (const void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

// # ifdef __OPTIMIZE__
// __extern_always_inline void *
// memchr (void *__s, int __c, size_t __n) __THROW
// {
//   return __builtin_memchr (__s, __c, __n);
// }// /* Compare N bytes of S1 and S2.  */
// extern int memcmp (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
//    Return some non-zero value otherwise.

//    Essentially __memcmpeq has the exact same semantics as memcmp
//    except the return value is less constrained.  memcmp is always a
//    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
//    or bcmp are correct implementations.

//    __memcmpeq is meant to be used by compilers when memcmp return is
//    only used for its bolean value.

//    __memcmpeq is declared only for use by compilers.  Programs should
//    continue to use memcmp.  */
// extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Search N bytes of S for C.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
// extern "C++"
// {
// extern void *memchr (void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
// extern const void *memchr (const void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

// # ifdef __OPTIMIZE__
// __extern_always_inline void *
// memchr (void *__s, int __c, size_t __n) __THROW
// {
//   return __builtin_memchr (__s, __c, __n);
// }// /* Compare N bytes of S1 and S2.  */
// extern int memcmp (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
//    Return some non-zero value otherwise.

//    Essentially __memcmpeq has the exact same semantics as memcmp
//    except the return value is less constrained.  memcmp is always a
//    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
//    or bcmp are correct implementations.

//    __memcmpeq is meant to be used by compilers when memcmp return is
//    only used for its bolean value.

//    __memcmpeq is declared only for use by compilers.  Programs should
//    continue to use memcmp.  */
// extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Search N bytes of S for C.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
// extern "C++"
// {
// extern void *memchr (void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
// extern const void *memchr (const void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

// # ifdef __OPTIMIZE__
// __extern_always_inline void *
// memchr (void *__s, int __c, size_t __n) __THROW
// {
//   return __builtin_memchr (__s, __c, __n);
// }
char encrypt_string2(char *string)
{
    // /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }
    char *ptr = string;
    // /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }
    int i = 0;

    while (string[i] != '\0')
    {
        // /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }
        *ptr = *ptr + 1;
        // /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }
        ptr++;
        // /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }
        i++;
    }
    // /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }
    strrev(string); // /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }
}
// /* Compare N bytes of S1 and S2.  */
// extern int memcmp (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
//    Return some non-zero value otherwise.

//    Essentially __memcmpeq has the exact same semantics as memcmp
//    except the return value is less constrained.  memcmp is always a
//    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
//    or bcmp are correct implementations.

//    __memcmpeq is meant to be used by compilers when memcmp return is
//    only used for its bolean value.

//    __memcmpeq is declared only for use by compilers.  Programs should
//    continue to use memcmp.  */
// extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Search N bytes of S for C.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
// extern "C++"
// {
// extern void *memchr (void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
// extern const void *memchr (const void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

// # ifdef __OPTIMIZE__
// __extern_always_inline void *
// memchr (void *__s, int __c, size_t __n) __THROW
// {
//   return __builtin_memchr (__s, __c, __n);
// }// /* Compare N bytes of S1 and S2.  */
// extern int memcmp (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
//    Return some non-zero value otherwise.

//    Essentially __memcmpeq has the exact same semantics as memcmp
//    except the return value is less constrained.  memcmp is always a
//    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
//    or bcmp are correct implementations.

//    __memcmpeq is meant to be used by compilers when memcmp return is
//    only used for its bolean value.

//    __memcmpeq is declared only for use by compilers.  Programs should
//    continue to use memcmp.  */
// extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Search N bytes of S for C.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
// extern "C++"
// {
// extern void *memchr (void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
// extern const void *memchr (const void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

// # ifdef __OPTIMIZE__
// __extern_always_inline void *
// memchr (void *__s, int __c, size_t __n) __THROW
// {
//   return __builtin_memchr (__s, __c, __n);
// }// /* Compare N bytes of S1 and S2.  */
// extern int memcmp (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
//    Return some non-zero value otherwise.

//    Essentially __memcmpeq has the exact same semantics as memcmp
//    except the return value is less constrained.  memcmp is always a
//    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
//    or bcmp are correct implementations.

//    __memcmpeq is meant to be used by compilers when memcmp return is
//    only used for its bolean value.

//    __memcmpeq is declared only for use by compilers.  Programs should
//    continue to use memcmp.  */
// extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Search N bytes of S for C.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
// extern "C++"
// {
// extern void *memchr (void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
// extern const void *memchr (const void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

// # ifdef __OPTIMIZE__
// __extern_always_inline void *
// memchr (void *__s, int __c, size_t __n) __THROW
// {
//   return __builtin_memchr (__s, __c, __n);
// }
char decrypt_string2(char *string)
{
    // /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }
    char *ptr = string;

    int i = 0;
    // /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }
    strrev(string);

    while (string[i] != '\0')
    {
        // /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }
        *ptr = *ptr - 1;
        // /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }
        ptr++;
        // /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }
        i++;
    } // /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }
}
// /* Compare N bytes of S1 and S2.  */
// extern int memcmp (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
//    Return some non-zero value otherwise.

//    Essentially __memcmpeq has the exact same semantics as memcmp
//    except the return value is less constrained.  memcmp is always a
//    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
//    or bcmp are correct implementations.

//    __memcmpeq is meant to be used by compilers when memcmp return is
//    only used for its bolean value.

//    __memcmpeq is declared only for use by compilers.  Programs should
//    continue to use memcmp.  */
// extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Search N bytes of S for C.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
// extern "C++"
// {
// extern void *memchr (void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
// extern const void *memchr (const void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

// # ifdef __OPTIMIZE__
// __extern_always_inline void *
// memchr (void *__s, int __c, size_t __n) __THROW
// {
//   return __builtin_memchr (__s, __c, __n);
// }// /* Compare N bytes of S1 and S2.  */
// extern int memcmp (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
//    Return some non-zero value otherwise.

//    Essentially __memcmpeq has the exact same semantics as memcmp
//    except the return value is less constrained.  memcmp is always a
//    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
//    or bcmp are correct implementations.

//    __memcmpeq is meant to be used by compilers when memcmp return is
//    only used for its bolean value.

//    __memcmpeq is declared only for use by compilers.  Programs should
//    continue to use memcmp.  */
// extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Search N bytes of S for C.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
// extern "C++"
// {
// extern void *memchr (void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
// extern const void *memchr (const void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

// # ifdef __OPTIMIZE__
// __extern_always_inline void *
// memchr (void *__s, int __c, size_t __n) __THROW
// {
//   return __builtin_memchr (__s, __c, __n);
// }// /* Compare N bytes of S1 and S2.  */
// extern int memcmp (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
//    Return some non-zero value otherwise.

//    Essentially __memcmpeq has the exact same semantics as memcmp
//    except the return value is less constrained.  memcmp is always a
//    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
//    or bcmp are correct implementations.

//    __memcmpeq is meant to be used by compilers when memcmp return is
//    only used for its bolean value.

//    __memcmpeq is declared only for use by compilers.  Programs should
//    continue to use memcmp.  */
// extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Search N bytes of S for C.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
// extern "C++"
// {
// extern void *memchr (void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
// extern const void *memchr (const void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

// # ifdef __OPTIMIZE__
// __extern_always_inline void *
// memchr (void *__s, int __c, size_t __n) __THROW
// {
//   return __builtin_memchr (__s, __c, __n);
// }// /* Compare N bytes of S1 and S2.  */
// extern int memcmp (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
//    Return some non-zero value otherwise.

//    Essentially __memcmpeq has the exact same semantics as memcmp
//    except the return value is less constrained.  memcmp is always a
//    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
//    or bcmp are correct implementations.

//    __memcmpeq is meant to be used by compilers when memcmp return is
//    only used for its bolean value.

//    __memcmpeq is declared only for use by compilers.  Programs should
//    continue to use memcmp.  */
// extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Search N bytes of S for C.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
// extern "C++"
// {
// extern void *memchr (void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
// extern const void *memchr (const void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

// # ifdef __OPTIMIZE__
// __extern_always_inline void *
// memchr (void *__s, int __c, size_t __n) __THROW
// {
//   return __builtin_memchr (__s, __c, __n);
// }// /* Compare N bytes of S1 and S2.  */
// extern int memcmp (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
//    Return some non-zero value otherwise.

//    Essentially __memcmpeq has the exact same semantics as memcmp
//    except the return value is less constrained.  memcmp is always a
//    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
//    or bcmp are correct implementations.

//    __memcmpeq is meant to be used by compilers when memcmp return is
//    only used for its bolean value.

//    __memcmpeq is declared only for use by compilers.  Programs should
//    continue to use memcmp.  */
// extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Search N bytes of S for C.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
// extern "C++"
// {
// extern void *memchr (void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
// extern const void *memchr (const void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

// # ifdef __OPTIMIZE__
// __extern_always_inline void *
// memchr (void *__s, int __c, size_t __n) __THROW
// {
//   return __builtin_memchr (__s, __c, __n);
// }// /* Compare N bytes of S1 and S2.  */
// extern int memcmp (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
//    Return some non-zero value otherwise.

//    Essentially __memcmpeq has the exact same semantics as memcmp
//    except the return value is less constrained.  memcmp is always a
//    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
//    or bcmp are correct implementations.

//    __memcmpeq is meant to be used by compilers when memcmp return is
//    only used for its bolean value.

//    __memcmpeq is declared only for use by compilers.  Programs should
//    continue to use memcmp.  */
// extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Search N bytes of S for C.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
// extern "C++"
// {
// extern void *memchr (void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
// extern const void *memchr (const void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

// # ifdef __OPTIMIZE__
// __extern_always_inline void *
// memchr (void *__s, int __c, size_t __n) __THROW
// {
//   return __builtin_memchr (__s, __c, __n);
// }// /* Compare N bytes of S1 and S2.  */
// extern int memcmp (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
//    Return some non-zero value otherwise.

//    Essentially __memcmpeq has the exact same semantics as memcmp
//    except the return value is less constrained.  memcmp is always a
//    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
//    or bcmp are correct implementations.

//    __memcmpeq is meant to be used by compilers when memcmp return is
//    only used for its bolean value.

//    __memcmpeq is declared only for use by compilers.  Programs should
//    continue to use memcmp.  */
// extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
//      __THROW __attribute_pure__ __nonnull ((1, 2));

// /* Search N bytes of S for C.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
// extern "C++"
// {
// extern void *memchr (void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
// extern const void *memchr (const void *__s, int __c, size_t __n)
//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

// # ifdef __OPTIMIZE__
// __extern_always_inline void *
// memchr (void *__s, int __c, size_t __n) __THROW
// {
//   return __builtin_memchr (__s, __c, __n);
// }
char encrypt_string(char *string)
{
    char *ptr = string;
    // /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }
    // strcpy(ptr2, string);

    int i = 0;
    while (string[i] != '\0')
    { // /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }
        if (string[i] == '!' || string[i] == '~' || string[i] == '"' || string[i] == '}')
        { // /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }
            *ptr = *ptr + 0;
            i++;
            // /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }
            ptr++; // /* Compare N bytes of S1 and S2.  */
                   // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                   //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }
        }
        // /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }
        else
        {
            if (i % 17 == 1)
            { // /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }
                string[i] = '{';
                i++; // /* Compare N bytes of S1 and S2.  */
                     // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                     //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }
                ptr++;
            } // /* Compare N bytes of S1 and S2.  */
              // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
              //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }

            else if (i % 11 == 2)
            {
                *ptr = *ptr - 2;
                i++;
                ptr++;
            }
            // /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }
            else if (i % 10 == 0)
            {
                *ptr = *ptr - 2;
                i++;
                ptr++; // /* Compare N bytes of S1 and S2.  */
                       // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                       //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }
            }

            else if (i % 9 == 0)
            {
                *ptr = *ptr - 2;
                i++;
                ptr++; // /* Compare N bytes of S1 and S2.  */
                       // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                       //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }
            }

            else if (i % 8 == 0)
            {
                string[i] = ';';
                i++;
                ptr++; // /* Compare N bytes of S1 and S2.  */
                       // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                       //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }
            }

            else if (i % 7 == 0)
            {
                *ptr = *ptr - 2;
                i++;
                ptr++;
            }

            else if (i % 6 == 0)
            {
                *ptr = *ptr - 2;
                i++;
                ptr++; // /* Compare N bytes of S1 and S2.  */
                       // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                       //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }
            }

            else if (i % 4 == 0)
            {
                *ptr = *ptr - 2;
                i++;
                ptr++; // /* Compare N bytes of S1 and S2.  */
                       // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                       //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }
            }

            else if (i % 3 == 0)
            {
                *ptr = *ptr - 2;
                i++; // /* Compare N bytes of S1 and S2.  */
                     // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                     //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }
                ptr++;
            }

            else if (i % 3 == 0)
            {
                string[i] = '0';
                i++; // /* Compare N bytes of S1 and S2.  */
                     // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                     //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }
                ptr++;
            } // /* Compare N bytes of S1 and S2.  */
              // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
              //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }

            else if (i % 2 == 0)
            {
                *ptr = *ptr + 2;
                i++; // /* Compare N bytes of S1 and S2.  */
                     // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                     //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }
                ptr++; // /* Compare N bytes of S1 and S2.  */
                       // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                       //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }
            }
            else
            { // /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }

                *ptr = *ptr + 1;
                i++; // /* Compare N bytes of S1 and S2.  */
                     // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                     //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }
                ptr++;
            } // /* Compare N bytes of S1 and S2.  */
              // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
              //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }
        }
    } // /* Compare N bytes of S1 and S2.  */
      // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
      //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }
    strrev(string);

    char string2[500];

    strcpy(string2, string); // /* Compare N bytes of S1 and S2.  */
                             // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                             //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }

    char *ptr2 = string2;
    // /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }
    i = 0;
    while (string2[i] != '\0')
    { // /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }
        if (string2[i] == '!' || string2[i] == '~' || string2[i] == '"' || string2[i] == '}')
        {
            *ptr2 = *ptr2 + 0;
            i++;
            ptr2++; // /* Compare N bytes of S1 and S2.  */
                    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                    //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }
        }

        else
        { // /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }
            if (i % 5 == 0)
            {
                string2[i] = '?';
                i++;
                ptr2++; // /* Compare N bytes of S1 and S2.  */
                        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                        //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }
            }
            // /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }
            else if (i % 3 == 0)
            {
                *ptr2 = *ptr - 2;
                i++;
                // /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }
                ptr2++;
            }

            else if (i % 2 == 0)
            {
                *ptr2 = *ptr2 + 2;
                i++;
                ptr2++;
            }
            else
            {
                // /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }
                *ptr2 = *ptr2 + 1;
                i++;
                ptr2++;
            }
        }
    }

    strcat(string, string2);

    strrev(string);

    char string3[500];

    strcpy(string3, string2);

    char *ptr3 = string3;
    // /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }
    i = 0;
    while (string3[i] != '\0')
    {
        if (string3[i] == '!' || string3[i] == '~' || string3[i] == '"' || string3[i] == '}')
        {
            *ptr3 = *ptr3 + 0;
            i++;
            ptr3++;
        }
        // /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }// /* Compare N bytes of S1 and S2.  */
        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
        //    Return some non-zero value otherwise.

        //    Essentially __memcmpeq has the exact same semantics as memcmp
        //    except the return value is less constrained.  memcmp is always a
        //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
        //    or bcmp are correct implementations.

        //    __memcmpeq is meant to be used by compilers when memcmp return is
        //    only used for its bolean value.

        //    __memcmpeq is declared only for use by compilers.  Programs should
        //    continue to use memcmp.  */
        // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
        //      __THROW __attribute_pure__ __nonnull ((1, 2));

        // /* Search N bytes of S for C.  */
        // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
        // extern "C++"
        // {
        // extern void *memchr (void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
        // extern const void *memchr (const void *__s, int __c, size_t __n)
        //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

        // # ifdef __OPTIMIZE__
        // __extern_always_inline void *
        // memchr (void *__s, int __c, size_t __n) __THROW
        // {
        //   return __builtin_memchr (__s, __c, __n);
        // }
        else
        {   // /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }// /* Compare N bytes of S1 and S2.  */
            // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
            //    Return some non-zero value otherwise.

            //    Essentially __memcmpeq has the exact same semantics as memcmp
            //    except the return value is less constrained.  memcmp is always a
            //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
            //    or bcmp are correct implementations.

            //    __memcmpeq is meant to be used by compilers when memcmp return is
            //    only used for its bolean value.

            //    __memcmpeq is declared only for use by compilers.  Programs should
            //    continue to use memcmp.  */
            // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
            //      __THROW __attribute_pure__ __nonnull ((1, 2));

            // /* Search N bytes of S for C.  */
            // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
            // extern "C++"
            // {
            // extern void *memchr (void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
            // extern const void *memchr (const void *__s, int __c, size_t __n)
            //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

            // # ifdef __OPTIMIZE__
            // __extern_always_inline void *
            // memchr (void *__s, int __c, size_t __n) __THROW
            // {
            //   return __builtin_memchr (__s, __c, __n);
            // }
            if (i % 15 == 2)
            {
                *ptr3 = *ptr3 - 2;
                i++; // /* Compare N bytes of S1 and S2.  */
                     // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                     //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }
                ptr3++;
            }

            else if (i % 6 == 0)
            {
                *ptr3 = *ptr3 - 1;
                i++;
                ptr3++; // /* Compare N bytes of S1 and S2.  */
                        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                        //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }
            }

            else if (i % 5 == 0)
            {
                *ptr3 = *ptr3 - 1; // /* Compare N bytes of S1 and S2.  */
                                   // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                                   //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }
                i++;
                ptr3++;
            }

            else if (i % 4 == 0)
            {
                *ptr3 = *ptr3 - 1; // /* Compare N bytes of S1 and S2.  */
                                   // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                                   //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }
                i++;
                ptr3++;
            }

            else if (i % 3 == 0)
            {
                *ptr3 = *ptr3 - 1;
                i++;
                ptr3++; // /* Compare N bytes of S1 and S2.  */
                        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                        //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }
            }

            else if (i % 2 == 0)
            {
                *ptr3 = *ptr3 + 1;
                i++;
                ptr3++; // /* Compare N bytes of S1 and S2.  */
                        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                        //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }
            }
            else
            {
                *ptr3 = *ptr3 + 2;
                i++;
                ptr3++; // /* Compare N bytes of S1 and S2.  */
                        // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                        //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }// /* Compare N bytes of S1 and S2.  */
                // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
                //    Return some non-zero value otherwise.

                //    Essentially __memcmpeq has the exact same semantics as memcmp
                //    except the return value is less constrained.  memcmp is always a
                //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
                //    or bcmp are correct implementations.

                //    __memcmpeq is meant to be used by compilers when memcmp return is
                //    only used for its bolean value.

                //    __memcmpeq is declared only for use by compilers.  Programs should
                //    continue to use memcmp.  */
                // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
                //      __THROW __attribute_pure__ __nonnull ((1, 2));

                // /* Search N bytes of S for C.  */
                // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
                // extern "C++"
                // {
                // extern void *memchr (void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
                // extern const void *memchr (const void *__s, int __c, size_t __n)
                //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

                // # ifdef __OPTIMIZE__
                // __extern_always_inline void *
                // memchr (void *__s, int __c, size_t __n) __THROW
                // {
                //   return __builtin_memchr (__s, __c, __n);
                // }
            }
        }
    }
    // /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }
    strcat(string, string3);
    // /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }// /* Compare N bytes of S1 and S2.  */
    // extern int memcmp (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
    //    Return some non-zero value otherwise.

    //    Essentially __memcmpeq has the exact same semantics as memcmp
    //    except the return value is less constrained.  memcmp is always a
    //    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
    //    or bcmp are correct implementations.

    //    __memcmpeq is meant to be used by compilers when memcmp return is
    //    only used for its bolean value.

    //    __memcmpeq is declared only for use by compilers.  Programs should
    //    continue to use memcmp.  */
    // extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
    //      __THROW __attribute_pure__ __nonnull ((1, 2));

    // /* Search N bytes of S for C.  */
    // #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
    // extern "C++"
    // {
    // extern void *memchr (void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
    // extern const void *memchr (const void *__s, int __c, size_t __n)
    //       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

    // # ifdef __OPTIMIZE__
    // __extern_always_inline void *
    // memchr (void *__s, int __c, size_t __n) __THROW
    // {
    //   return __builtin_memchr (__s, __c, __n);
    // }
    strrev(string);
}
